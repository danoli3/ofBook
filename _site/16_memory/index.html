








<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
	
  <title></title>

<!-- syntax highlighting for the documentation -->
<script src="http://localhost:8080/js/shCore.js" type="text/javascript"></script>
<script src="http://localhost:8080/js/shAutoloader.js" type="text/javascript"></script>
<script src="http://localhost:8080/js/shBrushCpp.js" type="text/javascript"></script>
<script src="http://localhost:8080/js/shBrushJava.js" type="text/javascript"></script>
<script src="http://localhost:8080/js/shBrushXml.js" type="text/javascript"></script>
<link href="http://localhost:8080/css/shCore.css" rel="stylesheet" type="text/css" />
<link href="http://localhost:8080/css/shThemeDefault.css" rel="stylesheet" type="text/css" />

<link rel="stylesheet" type="text/css" href="http://localhost:8080/css/style.css" media="all" />
<link rel="stylesheet" type="text/css" href="http://localhost:8080/css/print.css" media="print" />
<link href='http://fonts.googleapis.com/css?family=Questrial' rel='stylesheet' type='text/css'>
<link rel="search" type="application/opensearchdescription+xml" href="http://localhost:8080/opensearch.xml" title="openFrameworks" />

<link rel="shortcut icon" href="http://localhost:8080/favicon.ico" />
<link rel="icon" href="http://localhost:8080/favicon.ico" type="image/x-icon" />

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js" type="text/javascript"></script>
<script type="text/javascript" src="http://localhost:8080/js/jquery.timeago.js" type="text/javascript"></script>

<meta name="google-site-verification" content="RiGtl9pFuFnUeEQ4MU1miiutTR5mmCPUi38YLCn-M-g" />


    <script src="http://localhost:8080/js/jquery.columnizer.min.js"></script>
    <script src="http://localhost:8080/js/documentation.js"></script>
  </head>
  <body>
    <div id="content">
      
  

<div id="head">

		<div id="head-left">
			<a href="http://localhost:8080" class="nohover"><img src="http://localhost:8080/images/of-logo.svg" border="0" alt="openFrameworks" /></a>
		</div>

		<div id="head-right">
        <ul class="submenu">
        </ul>
		</div>
</div><!-- head -->



      <div id="body-wrap">	
	    <div class="page-wide-tutorial">
    	    <div class="article">
    	    
  <h1 id="memory-in-c">Memory in c++</h1>
<p><em>by <a href="http://arturocastro.net">Arturo Castro</a></em></p>
<p>Correctly using the memory is one of the trickest parts of working with c++. The main difference with other languages like Java, Python and in general any language that works with a virtual machine is that in c++ we can explicitly reserve and destroy objects while in those an element called garbage collector does the work for us.</p>
<p>There's also an important difference, in c++ we have two different memory areas, the heap and the stack, if you are used to work with processing, Java or Python you'll be used to only have heap memory.</p>
<p>We'll see later what the main differences are, but first let's see what's memory and what happens when we create variables in our program.</p>
<h2 id="computer-memory-and-variables">Computer memory and variables</h2>
<p>It's helpful to understand at least at a high level how computer memory works.</p>
<p>A computer has different types of memory, in this section we are going to be talking about RAM (Random Access Memory) memory. The kind of memory where the computer stores the code for the programs that are executing at every moment and the data those programs are using.</p>
<p>Your computer probably has something like 4Gb of RAM, in c++ we can access most of that memory, and to access it what we do is create variables.</p>
<p>For example when we create a variable like:</p>
<pre><code class="cpp">int i;
</code></pre>

<p>what we are doing is reserve 4 bytes of those 4Gb to store an int, it doesn't really matter if we are storing ints or other types of data, the sizes might be different for and int a char, a float or a string but the type of memory is always the same.</p>
<p>Internally the computer doens't really now about that memory area as i but as a memory address. A memory address is just a number that points to a specific byte in the 4Gb of memory.</p>
<p>When we create a variable like <code>int i</code> we are telling our program to reserve 4 bytes of memory, associate the address of the first byte of those 4 to the variable name <code>i</code> and restrict the type of data that we are going to store in those 4 bytes to only ints.</p>
<p><img src="int_i.svg" height="300"/></p>
<p>Usually memory addresses are represented in <a href="http://en.wikipedia.org/wiki/Hexadecimal">hexadecimal</a>. In c++ you can get the memory address of a variable by using the <code>&amp;</code> operator, like:</p>
<pre><code class="cpp">cout &lt;&lt; &amp;i &lt;&lt; endl;
</code></pre>

<p>The output of that cout is the memory address of the first byte of the variable <code>i</code> we just created.</p>
<p>Later on when we asign a value to that variable, what it's happening is that we are storing that value in the memory area that we've just reserved by declaring the variable, so when we do:</p>
<pre><code class="cpp">i = 0;
</code></pre>

<p>Our memory will look like:</p>
<p><img src="int_i_equals_0.svg" height="300"/></p>
<p>The order in which the bytes that form the int are layed out in the memory depends on the architecture of our computer, you'll prpbably seen <a href="http://en.wikipedia.org/wiki/Endianness">little endian and big endian</a> mentioned sometime. Those terms refer to how the bytes of a data type are ordered in memory, if the most significative bytes come first or last. Most of the time we don't really need to know about this order but most modern computer architectures use little endian.</p>
<p>If you've used c++ for a while you've probably had crashes in your programs because of bad memory accesses. Usually the message you'll see is something like <code>segmentation fault...</code>. What does that mean?</p>
<p>When you create variables in a program, even in c++, you can't really access all the memory in the computer, for security reasons. Imagine you had your bank account opened in your browser, if any program could access all the memory in the computer a malign application could just access the memory of the browser and get that information or even modify it. To avoid it the operating system asigns chuncks of memory to every program. When your application starts it's asign a <code>segment</code> of memory, later on as you create variables if there's enough memory in that <code>segment</code> your variables will be create there. When there's not more memory available the application asks the operating system for another segment and starts using that. If you try to access a memory address that doesn't belong to a segment asigned to your application, the operating system just kills the application to avoid possible security risks.</p>
<p>How does that happen usually? Well most of the time you just don't try to access memory addresses by their number, so how's it possible that sometimes you try to access a variable and you get a segmentation fault. Most of the time this happens because you try to access a varible that doesn't exist anymore, usually because you stored a pointer to a memory area and then free or move that memory somewhere else. We'll talk in more detail about this later</p>
<h2 id="stack-variables-variables-in-functions-vs-variables-in-objects">Stack variables, variables in functions vs variables in objects</h2>
<p>As we said at the beginning of the chapter there's two types of memory in c++ the stack and the heap. Let's talk first about the stack since that's the easiest type of memory to use and what you'll use more frequently in openFrameworks.</p>
<p>The stack is the type of memory that you use when creating variables inside a function or in the .h of your class as long as you don't use pointers and the keyword new.</p>
<p>It's called stack because it's organized like a <a href="http://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29">stack</a>. When in our application we call a function, there's an area in memory asigned to that function <strong>call</strong> where it can create variables in that area. </p>
<p>Those variables stop existing when the function call ends. So for example you can't do:</p>
<pre><code class="cpp">void ofApp::setup(){
    int a = 0;
}

void ofApp::update(){
    a = 5; // error a doesn't exist outside setup
}
</code></pre>

<p>Also since we are talking about function calls you can store a value in an stack variable and expect it to be there when the function is called again.</p>
<p>In general we can say that variables exist in the block they've been defined, a block in c++ is defined by the <code>{}</code> inside which a variable was defined, so for example, doing this won't be valid either:</p>
<pre><code class="cpp">for (int i=0;i&lt;10;i++){
    int a = 5;
}
cout &lt;&lt; a &lt;&lt; endl; // error a doesn't exist outside the {} of the for
</code></pre>

<p>We can even do this:</p>
<pre><code class="cpp">void ofApp::setup(){
   {
        int a = 0;
        // do something with a
   }

   {
        int a = 0;
        // do something with a
   }
}
</code></pre>

<p>which is not very common but is used sometimes to define the life of a variable inside a function, mostly when that variable is an object that holds resources and we want to only hold them for a specific time.</p>
<p>The life of a variable is called <code>scope</code>.</p>
<p>Apart from creating variables inside functions we can also create variables in the class declaration in our .h like:</p>
<pre><code class="cpp">class Ball{
public:
    void setup();

    float pos_x;
}
</code></pre>

<p>These kind of variables are called <code>instance variables</code> because every instance or object of our class will get a copy of it. The way they behave is the more or less the same as the stack variables created in functions. They exist for the duration of the {} in which they were defined, in this case the {} of the object to which they belong.</p>
<p>These variables can be accessed from anywhere in the class so when we need to have data that is accessible from any function in an object of this class we create it like this.</p>
<p>The memory in the stack is limited, the exact size, depends on the architecture of our computer, the operating system and even the compiler we are using. In some systems it can even be changed during the runtime of the application, but most of the time we won't hit that limit.</p>
<p>Even if we create all of our variables in the stack, usually the objects that consume most memory like for example a vector or in openFrameworks something like ofPixels, will create most of the memory they use internally in the heap which is only limited by the amount of memory available in the computer so we don't need to worry about it.</p>
<p>We'll see in the next sections how the heap works and what are the advantages of using the heap or the stack.</p>
<h2 id="pointers-and-references">Pointers and references</h2>
<p>Before talking about heap memory let's see how pointers and references work in c++, what's their syntax and what's really happening with memory when we create a pointer or a reference.</p>
<p>As we've seen before we can get the address of a variable by doing:</p>
<pre><code class="cpp">cout &lt;&lt; &amp;i &lt;&lt; endl;
</code></pre>

<p>And that will give us the memory address of the first byte used by that variable no matter it's type. When we store that memory address in another variable that's what we call in c++ a pointer. The syntax is:</p>
<pre><code class="cpp">int i = 0;
int * p = &amp;i;
</code></pre>

<p>And what we get in memory is something like:</p>
<p><img src="pointer.svg" height="300"/></p>
<p>A pointer usually occupies 4 bytes, we are representing it as 1 byte only to make things easier to understand, but as you can see it's just another variable, that instead of containing a value contains a memory address that points to a value that's why it's called pointer.</p>
<p>A pointer can point to heap or stack memory.</p>
<p>Now, let's explain something that it's really important to take into account when programming in c++. As we've seen till now, when we declare a variable like:</p>
<pre><code class="cpp">int i;
</code></pre>

<p>We get a memory layout like:</p>
<p><img src="int_i.svg" height="300"/></p>
<p>As we see there's no value in that memory area yet. In other languages like processing doing something like:</p>
<pre><code class="java">int i;
println(i)
</code></pre>

<p>is illegal, the compiler will tell us that we are trying to use a variable that is not initialized. In c++ though, that's perfectly legal but the contents of that variable are undefined. Most of the times we'll get 0 because the operating system will clear the memory before assigning it to our program, again for security reasons. But if we are resuing memory that we had already assigned then that memory area will contain anything and the results of our program can be undefined.</p>
<p>If for example we have a variable that defined the position of something we are going to draw, failing to initialize it will lead to that object being drawn anywhere.</p>
<p>Now most objects have default constructors that will initialize their value to, for example 0, so in the case of objects it's usually not necessary to give them a value.</p>
<p>What happens when we use an initialized pointer? Well since a pointer is a memory address if the value we get in that memory area points to an address that doesn't belong to our program and we try to retrieve or modify the value stored in that address the OS will kill our application with a segmentation fault signal.</p>
<p>Back to pointers, we've seen that, we can create a pointer like:</p>
<pre><code class="cpp">int i = 5;
int * p = &amp;i;
</code></pre>

<p>now, if we try to use the pointer directly like;</p>
<pre><code class="cpp">cout &lt;&lt; p &lt;&lt;&lt; endl;
</code></pre>

<p>what we'll get is a memory address not the value 5. So how do we access the value pointed by a pointer, well we can use the opposite operator to <code>&amp;</code>, as <code>&amp;</code> gives us the address of a variable, <code>*</code> gives us the value pointed by a memory address, so we can do;</p>
<pre><code class="cpp">cout &lt;&lt; *p &lt;&lt; endl;
</code></pre>

<p>and we'll get the value 5 printed now. We can also do:</p>
<pre><code class="cpp">int j = *p;
cout &lt;&lt; j &lt;&lt; endl;
</code></pre>

<p>and again will get the value 5 since we made a copy of the value pointed by p in j.</p>
<p>The <code>&amp;</code>operator is called the <em>reference operator</em> since it gives us a reference to a variable, it's memory address. The <code>*</code> operator is it's opposite, the <em>dereference operator</em> and it gives us the value pointed by a pointer, it dereferences a reference, a memory address, so we can access it's value instead of the address.</p>
<p>Till now, we've work with primitive values, ints really but the behaviour will be the same for any other primitive value, like float, short, char, unsigned int...  In c++ in fact the behaviour is also the same for objects.</p>
<p>If you are used to Java, for example you've probably noticed that while in Java and C++ this:</p>
<pre><code class="cpp">int a = 5;
int b = a;
a = 7;
cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; &quot; b: &quot; &lt;&lt; b &lt;&lt; endl;
</code></pre>

<p>will behave the same, that's, a will end up being 7 and a will be 5. When we use objects the behaviour in c++ is different to that of Java. For example, let's say we have a class Ball:</p>
<pre><code class="cpp">class Ball{
public:
    void setup();
    //...

    ofVec2f pos;
}
</code></pre>

<p>or the similar class in processing;</p>
<pre><code class="java">class Ball{
    void setup();

    PVector pos;
}
</code></pre>

<p>if in c++ you do:</p>
<pre><code class="cpp">Ball b1;
b1.pos.set(20,20);
Ball b2;
b2 = b1;
b2.pos.set(30,30);
</code></pre>

<p>b1 pos will end up being 20,20 and b2 30,30 while if you do the equivalent in java both b1 and b2 will have position 30,30:</p>
<pre><code class="cpp">Ball b1 = new Ball();
b1.pos.set(20,20);
Ball b2;
b2 = b1;
b2.pos.set(30,30);
</code></pre>

<p>Notice how in the case of Java we have made new for the first ball but not for the second, that's because in Java everything that is an object is a pointer in the heap so when we do <code>b2 = b1</code>we are actually turning b2 into a reference to b1, and when we later change b2, we are also changing b1.</p>
<p>In c++, instead when we do <code>b2 = b1</code> we are actually copying the values of the variables of b1 into b2 so we still have 2 different variables instead of a reference. When we modify b2, b1 stays the same.</p>
<p>This is more or less what memory would look like in Java and C++:</p>
<p><img src="objects_java_c.svg" height="300"/></p>
<p>As you can see in c++ objects in memory are just all their member variables one after another. When we make an object variable equal to another, by default, c++ copies all the object to the left side of the equal operator.</p>
<p>Now what would happen if have a class like:</p>
<pre><code class="cpp">class Particle{
public:
    void setup();
    //...

    ofVec2f pos;
    ParticleSystem * parent;
}
</code></pre>

<p>And we do:</p>
<pre><code class="cpp">Particle p1;
Particle p2;
ParticleSystem ps;

p1.pos.set(20,20);
p1.parent = &amp;ps;
p2 = p1;
</code></pre>

<p>Well as before c++ will copy the contents of p1 on p2, the contents of p1 are an ofVec2f which consits of 2 floats x and y and then a pointer to a ParticleSystem, and that'w what gets copied, the ParticleSystem itself won't get copied only the pointer to it, so p2 will end up having a copy of the position of p2 and a pointer to the same ParticleSystem but we'll have only 1 particle system.</p>
<p><img src="object_pointers.svg" height="300"/></p>
<p>The fact that things are copied by default and that objects can be stored in the stack as oposed to being always pointer has certain adavantages. For example, in c++ a vector or an array of particles like the ones we've used in the last example will look like:</p>
<pre><code class="cpp">vector&lt;Particle&gt; particles;
</code></pre>

<p>in memory all the particles will be contiguous, among other things that makes accessing them faster than if we had pointers to a different location in memory. It also makes it easier to translate c++ vectors to openGL memory structures but that's the topic for another chapter.</p>
<p>Among other things we need to be aware of the fact that c++ copies things by default, when passing objects to functions as parameters. For example this:</p>
<pre><code class="cpp">void moveParticle(Particle p){
    p.x += 10;
    p.y += 10;
}

...

Particle p1;
moveParticle(p1);
</code></pre>

<p>Is perfectly valid code, but won't have any effect since the function will receive a copy of the particle and modify that copy instead of the original.</p>
<p>We can do this:</p>
<pre><code class="cpp">Particle moveParticle(Particle p){
    p.x += 10;
    p.y += 10;
    return p;
}
...

Particle p1;
p1 = moveParticle(p1);
</code></pre>

<p>So we pass a copy of our particle to the function which modifies it's values and returns a modified copy which we then copy into p1 again. See how many times we've mentiponed copy in the previous sentence?  The compiler will optimize some of those out and for small objects it's perfectly ok to do that but imagine we had something like this:</p>
<pre><code class="cpp">vector&lt;Particle&gt; moveParticles(vector&lt;Particle&gt; ps){
    for(int i=0;i&lt;ps.size();i++){
        ps[i].x += 10;
        ps[i].y += 10;
    }
    return ps;
}
...

vector&lt;Particle&gt; ps;
...
ps = moveParticles(ps);
</code></pre>

<p>If we have 1 million particles that will be awfully slow, memory is really slow compared to the cpu, so anything that involves copying memory or allocating new memory should be usually avoided. So what can we do to avoid all that copies?</p>
<p>Well we could use pointers right?</p>
<pre><code class="cpp">void moveParticle(Particle * p){
    p-&gt;x += 10;
    p-&gt;y += 10;
}
...

Particle p1;
moveParticle(&amp;p1);
</code></pre>

<p>Now, here's something new, notice how to refer to the variables of a pointer to an object instead of using the dot, we use the <code>-&gt;</code> operator, everytime we want to access a variable in a pointer to an object instead of having to dereference it like:</p>
<pre><code class="cpp">(*p).x +=10
</code></pre>

<p>we can use the <code>-&gt;</code></p>
<pre><code class="cpp">p-&gt;x += 10
</code></pre>

<p>So that solves our problem, using a pointer instead of passing a copy of the object, we are passing a reference to it, it's memory address, so the function will actually modify the original.</p>
<p>The main problem with this is that the syntax is kind of weird, imagine how would look like if we passed a pointer for the second example, the one with the vector:</p>
<pre><code class="cpp">vector&lt;Particle&gt; moveParticles(vector&lt;Particle&gt; ps){
    for(int i=0;i&lt;ps.size();i++){
        ps[i].pos.x += 10;
        ps[i].pos.y += 10;
    }
    return ps;
}
...

vector&lt;Particle&gt; ps;
...
ps = moveParticles(ps);
</code></pre>

<p>Now, the function will look like:</p>
<pre><code class="cpp">void moveParticles(vector&lt;Particle&gt; * ps){
</code></pre>

<p>the problem is that now we can't use the [] operator to access the elements in the vector cause ps is not a vector anymore but a pointer to a vector. What's more this</p>
<pre><code class="cpp">ps[i].x += 10;
</code></pre>

<p>would actually compile but would mostly sure give as a memory access error, a segmentation fault. ps is now a pointer and when using pointers the `[]' behaves like if we had an array of vectors!</p>
<p>Will explain this in more depth in the section about memory structures, but let's see how to pass a reference that doens't have pointer syntax. In c++ is called a reference and it looks like:</p>
<pre><code class="cpp">void moveParticles(vector&lt;Particle&gt; &amp; ps){
    for(int i=0;i&lt;ps.size();i++){
        ps[i].pos.x += 10;
        ps[i].pos.y += 10;
    }
}

vector&lt;Particle&gt; ps;
...
moveParticles(ps);
</code></pre>

<p>Now we are passing a reference to the original object but instead of having to use pointer syntax we can still use it as if it was a normal object.</p>
<blockquote>
<p>Advanced note: Some times we want to use references to avoid copies but still be sure that the function we pass our object to won't modify it's contents, in that case it's recomendable to use const like:</p>
</blockquote>
<pre><code class="cpp">ofVec2f averagePosition(const vector&lt;Particle&gt; &amp; ps){
    ofVec2f average;
    for(int i=0;i&lt;ps.size();i++){
        average += ps[1].pos;
    }
    return average/float(ps.size());
}
vector&lt;Particle&gt; ps;
...
ofVec2f averagePos = averagePosition(ps);
</code></pre>

<blockquote>
<p>const only makes it imposible to modify the variable even if it's a reference and tells anyone using that function that they can pass their data into it and it won't be changed, also anyone modifying that function knows that in the future it should stay the same and not modify the parameter</p>
</blockquote>
<p>Outside of parameters, references have a copule of special characteristics. </p>
<p>First we can't modify the content of a reference once it's created, for example we can do:</p>
<pre><code class="cpp">ofVec2f &amp; pos = p.pos;
pos.x = 5;
</code></pre>

<p>but trying to change the reference itself like in:</p>
<pre><code class="cpp">ofVec2f &amp; pos = p.pos;
pos.x = 5;
pos = p2.pos  // error, a reference can only be asigned on it's declaration
</code></pre>

<p>Also you can return a reference but depending on what that reference it's pointing to it can be a bad idea:</p>
<pre><code class="cpp">ofVec2f &amp; averagePosition(const vector&lt;Particle&gt; &amp; ps){
    ofVec2f average;
    for(int i=0;i&lt;ps.size();i++){
        average += ps[1].pos;
    }
    average/=float(ps.size());
    return average;
}
</code></pre>

<p>Will actually compile but will probably result in a segmentation fault at some point or even just work but will get weird values when calling this funciton. The problem is that we are creating the variable <code>average</code> in the stack so when the function returns it'll be deleted from memory, the reference we return will be pointing to a memory area that is not reserved anymore for average and as soon as it get overwritten we'll get invalid values or a pointer to a memory area that doesn't belong to our program anymore.</p>
<p>This is one of the most annoying problems in c++ it's called dangling pointers or in this case references and it's caused when we have a pointer or a reference that point to a memory area that is later freed somehow.</p>
<p>More modern langauges solve this with diferent strategies, for example Java won't let this happen since objects are only deleted once the last reference to them goes out of scope but it uses something called a garbage collector that from time to time goes through the memory looking for objects which have no more references pointing to them, and deletes them. This solves the problem but makes it hard to know when objects are going to get really deleted. c++ in it's latest version, c++11, and more modern languages try to solve this using new kinds of pointers that define ownership of the object, will talk about it in the latest section of this chpater, smart pointers.</p>
<h2 id="variables-in-the-heap">Variables in the heap</h2>
<p>Now that we now the syntax and semantics of pointers lets see how to use the heap. The heap is an area of memory common to all of our application, any function can create variables in this space and share it with others, to use it we need a new keyword <code>new</code>:</p>
<pre><code class="cpp">Particle * p1 = new Particle;
</code></pre>

<p>If you know processing or Java that looks a little bit like it, right? indeed this is exactly the same as a Java object, a pointer to a memory address in the heap, except that in c++ we explictly say that this is a pointer by using the <code>*</code> in the declaration.</p>
<p>To access the variables or functions of a pointer as we've seen before we use the <code>-&gt;</code> operator so we would do:</p>
<pre><code class="cpp">Particle * p1 = new Particle;
p1-&gt;pos.set(20,20);
</code></pre>

<p>or:</p>
<pre><code class="cpp">Particle * p1 = new Particle;
p1-&gt;setup();
</code></pre>

<p>A pointer as any variable can be declared but not initialized as we've seen before:</p>
<pre><code class="cpp">Particle * p1;
p1-&gt;setup() // this will compile but fail when executing the application
</code></pre>

<p>As we've said things created in the heap live as long as we want and any function can access them as long as they have a reference (a pointer) to them. For example:</p>
<pre><code class="cpp">Particle * createParticle(){
    return new Particle;
}

void modifyParticle(Particle * p){
    p-&gt;x += 10;
}

...

Particle * p = createParticle();
modifyParticle(p);
</code></pre>

<p>So how can we say that we don't want to use that variable anymore? we use the keyword <code>delete</code>:</p>
<pre><code class="cpp">Particle * p1 = new Particle;
p1-&gt;setup();
...
delete p1;
</code></pre>

<p>This is important when using the heap, if we fail to do this we'll get with what is called a memory leak, memory that is not referenced by anyone but continues to leave in the heap, making our application use more and more memory over time till it fills all the available memory in our computer:</p>
<pre><code class="cpp">void ofApp::draw(){
    Particle * p1 = new Particle;
    p1-&gt;setup();
    p1-&gt;draw();
}
</code></pre>

<p>every time we call draw, it'll create a new particle, once we get out of the function we loose the reference *p1 to it but the memory we allocated using new is not freed when the function call ends so our program will slowly get more and more memory, you can check it using the system monitor.</p>
<p>As we've mentioned before the stack memory is limited so sometimes we need to use the heap, trying to create 1 million particles in the stack will probably cause a stack overflow. In general, though, most of the time in c++ we don't need to use the heap, at least not directly, classes like vector, ofPixels and other memory structures allow us to use heap memory but still have stack semantics, for example this:</p>
<pre><code class="cpp">void ofApp::draw(){
    vector&lt;Particle&gt; particles;
    for(int i=0; i&lt;100; i++){
        particles.push_back(Particle())
        particles.back().setup();
        particles.back().draw();
    }
}
</code></pre>

<p>is actually using heap memory since the vector is internally using that, but the vector destructor will take care of freeing that memory for us as soon as the particles variable goes out of scope, when the current call to draw finishes.</p>
<h2 id="memory-structures-arrays-and-vectors">Memory structures, arrays and vectors</h2>
<p>Arrays are the most simple way in c++ to create collections of objects, as any other type in c++ they can also be created in the stack or in the heap. Arrays in the stack have a limitation though, they need to have a predifined size that needs to be specified in it's declaration and can't change after wards:</p>
<pre><code class="cpp">int arr[10];
</code></pre>

<p>the same as with any other type, the previous declaration already reserves memory for 10 ints, we don't need to use new, and that memory will be uninitialized. To access them, as you might now from previous chapters you can just do:</p>
<pre><code class="cpp">int arr[10];
arr[0] = 5;
int a = arr[0]
</code></pre>

<p>if we try to do:</p>
<pre><code class="cpp">int arr[10];
int a = arr[5];
</code></pre>

<p>the value of a will be undefined since the memory in the array is not initialized to any value when it's created. Also if we try to do:</p>
<pre><code class="cpp">int arr[10];
int a = arr[25];
</code></pre>

<p>most probably our application will crash if the memory address at arr + 25 is outside the memory that the operating system has asigned to our application.</p>
<p>We've just sayd arr + 25? what does that mean? As we've seen before a variable is some place in memory, we can get it's memory address which is the first byte that is asigned to that variable in memory. With arrays is pretty much the same, for example since we know that an int occupies 4 bytes in memory an array of 10 ints will occupy 40 bytes and those bytes are consecutive:</p>
<p><img src="array.svg" height="300"/></p>
<p>Remember that memory addresses are expressed as hexadecimal so 40 == 0x0028. Now to take the address of an array, as with other variable we might want to use the <code>&amp;</code> operator and indeed we can do it like:</p>
<pre><code class="cpp">int arr[0];
int * a = &amp;arr[0];
</code></pre>

<p>That gives us the address of the first element of the array which is indeed that of the array, but with arrays, the same variable is actually a pointer itself:</p>
<pre><code class="cpp">int arr[10];
int * a = &amp;arr[0];
cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; &quot; arr: &quot; &lt;&lt; arr &lt;&lt; endl;
</code></pre>

<p>will print the same value for both a and arr. So an array is just a pointer to a memory address with the only difference that, that memory address is the beginning of reserved memory enough to allocate, in our case 10 ints. All those ints will be one after another, so when we do <code>arr[5]</code> we are just accessing the value that is in the memory address of our array + the size of 5 ints. If our array started in <code>0x0010</code>, and ints ocupy <code>4 bytes</code>, arr[5] would be <code>10 + 4 * 5 = 30</code> which in hexadecimal is <code>0x001E</code>. We can actually do this in our code:</p>
<pre><code class="cpp">int arr[10]
arr[5] = 20;
cout &lt;&lt; &quot;&amp;arr[5]: &quot; &lt;&lt; &amp;arr[5] &lt;&lt; &quot;arr+5: &quot; &lt;&lt; arr+5 &lt;&lt; endl
cout &lt;&lt; &quot;arr[5]: &quot; &lt;&lt; arr[5] &lt;&lt; &quot;*(arr+5): &quot; &lt;&lt; *(arr+5) &lt;&lt; endl
</code></pre>

<p>now, that's really weird and most of the time you want use it, it's called pointer arithmetic. The first cout will print the address in memory of the int at position 5 in the array in the first case using the <code>&amp;</code> operator to get the address of <code>arr[5]</code> and in the second directly by adding 5 to the first address of the arr doing <code>arr+5</code>. In the second cout we print the value at that memory location, using <code>arr[5]</code> or dereferencing the address <code>arr+5</code> using the <code>*</code> operator.</p>
<p>Not that when we add <code>5</code> to the adress of the array it's not bytes we are adding but the size in bytes of the type it contain, in this case <code>+5</code> actually means <code>+20</code> bytes, you can check it by doing:</p>
<pre><code class="cpp">int arr[10]
arr[5] = 20;
cout &lt;&lt; &quot;arr: &quot; &lt;&lt; arr &lt;&lt; &quot;arr+5: &quot; &lt;&lt; arr+5 &lt;&lt; endl
</code></pre>

<p>and substracting the hexadecimal values in a calculator, if you try to substract them in your program like:</p>
<pre><code class="cpp">int arr[10]
arr[5] = 20;
cout &lt;&lt; &quot;arr: &quot; &lt;&lt; arr &lt;&lt; &quot;arr+5: &quot; &lt;&lt; arr+5 &lt;&lt; endl
cout &lt;&lt; &quot;(arr+5) - arr: &quot; &lt;&lt; (arr+5) - arr &lt;&lt; endl
</code></pre>

<p>You will end up with <code>5</code> again because as we've said pointer arithmetic works with the type size not in bytes.</p>
<p>The syntax of pointer arithmetics is kind of complicated, and the idea of this part wasn't really to show pointer arithmetics itself but how arrays are just a bunch of values one after another in memory, so not worries if you haven't understood fully the syntax is probably something you won't need to use. It is also important to remember that an array variable acts as a pointer so when we refer to it without using the <code>[]</code> operator we end up with a memory address not with the values it contains.</p>
<p>The arrays we've created till now are created in the stack so be careful when using big arrays like this cause it might be problematic. </p>
<p>Arrays in the heap are created like:</p>
<pre><code class="cpp">int arr[] = new int[10];
</code></pre>

<p>or</p>
<pre><code class="cpp">int * arr = new int[10]
</code></pre>

<p>As you can see this confirms what we've said before, an array variable is just a pointer, when we call <code>new int[10]</code> it allocates memory to store 10 integers and returns the memory address of the first byte of the first integer in the array, we can keep it in a pointer like in the second example or using <code>int arr[]</code> which declares an array of unkown variable.</p>
<p>The same as other variables created in the heap we'll need to delete this manually so when we are done with it we need to use <code>delete</code> to deallocate that memory, in the case of arrays in the heap the syntax is slightly special:</p>
<pre><code class="cpp">int arr[] = new int[10];
...
delete[] arr;
</code></pre>

<p>if you fail to use the <code>[]</code> when deleting it, it'll only deallocate the first value and you'll end up with a memory leak.</p>
<p>There's also some problems with the syntax of arrays, for example this:</p>
<pre><code class="cpp">int arr[10]
int arrB[10];
arrB = arr;
</code></pre>

<p>will fail to compile. And this:</p>
<pre><code class="cpp">int arr[] = new int[10];
int arrB[] = new int[10];
arrB = arr;
</code></pre>

<p>will actually compile but as with other variables we are not copying the values that arr points to into arrB but instead the memory address. In this case will end up with 2 pointers pointing to the same memory location, the one that we created when creating arr and loose the memory that we allocated when initializing arrB. Again we have a memory leak, the memory allocated when doing <code>int arrB[] = new int[10];</code> is not referenced by any variable anymore so we can delete it. To copy arrays there's some <strong>c</strong> (not c++) functions liek memcpy but their syntax is kind of complex, that's why when working with c++ is recomended to use vectors.</p>
<p>C++ vectors are very similar to arrays, indeed their layout in memory is the same as an array, they contain a bunch of values contiguous in memory and always allocated in the heap. The main difference is that we get a nicer syntax and stack semantics. To allocate a vector to contain 10 ints we can do:</p>
<pre><code class="cpp">vector&lt;int&gt; vec(10);
</code></pre>

<p>We can even give an initial value to those 10 ints in the initialization like:</p>
<pre><code class="cpp">vector&lt;int&gt; vec(10,0);
</code></pre>

<p>And for example copying a vector into another works as expected:</p>
<pre><code class="cpp">vector&lt;int&gt; vec(10,0);
vector&lt;int&gt; vecB = vec;
</code></pre>

<p>Will create a copy of the contents of vec in vecB. Also even if the memory that the vector uses is in the heap, when a vector goes out of scope, when the block in which it was declared ends, the vector is destroyed cause the vector itself is created in the stack, which triggers it's destructor that takes care of deleting the memory that it has created in the heap:</p>
<pre><code class="cpp">void ofApp::update(){
    vector&lt;int&gt; vec(10);
    ...
}

That makes vectors easier to use than arrays since we don't need to care about deleting them, end up with dangling pointers, memory leaks... and their syntax is easier.

Vectors have some more features and using them properly might be tricky mostly if we want to optimize for performance or use them in multithreaded applications, but thats not the scope of this chapter, you can find some tutorials about vectors, this is an introductory one in the openFrameworks site: [vectors basics](http://openframeworks.cc/tutorials/c++%20concepts/001_stl_vectors_basic.html) and this one explains more advanced concepts [std::vector](http://arturocastro.net/blog/2011/10/28/stl::vector/)

## Other memory structures, maps, sets and lists ##

Having objects in memory one after another is most of the time what we want, the access is really fast no matter if we want to access sequentially to each of them or randomly to anyone, since a vector is just an array internally, accesing let's say position 20 in it, just means that internally it just needs to get the memory address of the first position and add 20 to it. In soime cases though vectors are not the most optimal memory structure, for example, if we want to frequnetly add  or remove elements in the middle of the vector, and you imagine the vector as a memory strip, that means that we need to move the rest of the vector till the end one position to the right and then insert the new element in the free location. In memory there's no such thing as move, moving contiguous memory means copying it and as we've said before, copying memory is a relatively slow operation.

&lt;img src=&quot;vector_inserting.svg&quot; height=&quot;300&quot;/&gt;

Sometimes, if there's not enough memory to move/copy the elements, one position to the right, the vector will need to copy the whole thing to a new memory location. If we are working with thousands of elements and doing this very frequently, like for example every frame, this can really slow things down a lot.

To solve that, there's other memory structures like for example lists. In a list memory is not contiguous but instead each element has a pointer to the next and previous element so inserting one element just means changing those pointers to point to the newly added element. In a list we never need to move elements around but it's main disadvantage is that not being the elements contiguous in memory it's access can be slightly slower than a vector, also that we can't use it in certain cases like for example to upload data to the graphics card which always wants contiguos memory.

&lt;img src=&quot;list.svg&quot; height=&quot;300&quot;/&gt;

Another problem of lists is that trying to access an element in the middle of the list (what is called random access) is slow since we always have to go through all the list till we arrive to the desired element. Lists are used then when we seldom need to access randomly to a position of it and we need to add or remove elements in the middle frequently. For the specifics of the syntax of a list you can check the [c++ documentation on lists](http://www.cplusplus.com/reference/list/list/)

There's several memory structures in the c++ standard library or other c++ libraries, apart from vectors and lists we are going to see briefly maps and sets.

Sometimes, we don't want to access things by their position or have an ordered list of elements but instead have something like an index of elements that we can access by some key, that's what a map is, in a map we can store pairs of key,values and look for a value by it's key. For example let's say we have a collection of objects which have a name, that name must be unique but we can store those elements in a map to be able to look for them by their name:

```cpp
map&lt;string, NamedObject&gt; objectsMap;

NamedObject o1;
o1.name = &quot;object1&quot;;
objectsMap[o1.name] = o1;
</code></pre>

<p>Later on we can look for that object using it's name like:</p>
<pre><code class="cpp">objectsMap[&quot;object1&quot;].doSomething();
</code></pre>

<p>Be careful though, if the object didn't exist before, using the <code>[]</code> operator will create a new one, if you are not sure it's usually wise to try to find it first and only use it if it exists:</p>
<pre><code class="cpp">if(objectsMap.find(&quot;object1&quot;)!=objectsMap.end()){
    objectsMap[&quot;object1&quot;].doSomething();
}
</code></pre>

<p>You can find the complete reference on maps in the <a href="http://www.cplusplus.com/reference/map/map/">c++ documentation for maps</a></p>
<h2 id="smart-pointers">smart pointers</h2>
<p>As we've said before, traditional c pointers also called now <em>raw pointers</em> are sometimes problematic, the most frequent problems are dangling pointers: pointers that probably were once va√±lid but now point to an invalid memory location, trying to dereference a NULL pointer, posible memory leaks if we fail to deallocate memory before loosing the reference to that memory address..</p>
<p>Smart pointers try to solve that by adding what we've been calling stack semantics to memory allocation, the correct term for this is RAII: <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">Resource Acquisition Is Initialization</a> And means that the creation of an object, usually in the stack, allocates the resources that it'll use later, when it's destructor is called because the variable goes out of scope the destructor of the object is triggered which takes care of deallocating all the used resources. There's some more implications to RAII but for this chapter this is what matter to us more.</p>
<p>Smart pointers use this technique to avoid all the problems that we've seen in raw pointers. They do this by also defining better who is the owner of some allocated memory or object. Till now we've seen how things allocated in the stack belong to the function or block that creates them we can return a copy of them (or in c++11 move them) out of a function as a return value but their ownership is always clear.</p>
<p>With heap memory though ownership becomes way more fuzzy, someone might create a variable in the heap like:</p>
<pre><code class="cpp">int * createFive(){
    int a = new int;
    *a = 5;
}
</code></pre>

<p>Now, when someone calls that function who is the owner of the <code>new int</code>? Things can get even more complicated, what if we pass a pointer to that memory to another function or even an object?</p>
<pre><code class="cpp">// ofApp.h
int * a;
SomeObject object;

// ofApp.cpp
void ofApp::setup(){
    a = createFive();
    object.setNumber(a);
}
</code></pre>

<p>who is now the owner of that memory? ofApp? object? The ownership defines among other things who is responsible for deleting that memory when it's not used anymore, now both ofApp and object have a reference to it, if ofApp deletes it before object is done with it object might try to access it and crash the application, or the other way around. In this case it seems logical that ofApp takes care of deleting it since it knows about both object and the pointer to int a, but what if we change the example to :</p>
<pre><code class="cpp">// ofApp.h
SomeObject object;

// ofApp.cpp
void ofApp::setup(){
    int * a = createFive();
    object.setNumber(a);
}
</code></pre>

<p>or even:</p>
<pre><code class="cpp">// ofApp.h
SomeObject object;

// ofApp.cpp
void ofApp::setup(){
    object.setNumber(createFive());
}
</code></pre>

<p>now ofApp doesn't know anymore about the allocated memory but both cases are possible so we actually need to know details of the implementation of object to know if we need to keep a reference of that variable to destroy it later or not. That among other things breaks encapsulation, that you might now from chapter 1. We shouldn't need to know how object works internally to be able to use it. And makes the logic of our code really complicated and error prone.</p>
<p>Smart pointers solve this by clearly defining who owns and object and delting the allocated memory when the owner is destroyed, sometimes, we need to share an object in that case smart pointers define a shared ownership and destroy the allocated memory only when all the owners cease to use the variable.</p>
<p>We are only going to see this briefly, there's lots of examples in the web about how to use smart pointers and reference to their syntax, the most important is to understand how they work by defining the ownership clearly compared to raw pointers and the problems they solve.</p>
<h3 id="unique_ptr">unique_ptr</h3>
<p>A unique_ptr, as it's name suggests, is a pointer that defines a unique ownership for an object, we can move it around and the object or function that has it at some point is the owner of it, no more than one reference at the same time is valid and when it goes out of scope it automatically deletes any memory that we might have allocated.</p>
<p>To allocate memory using a unique_ptr we do:</p>
<pre><code class="cpp">void ofApp::setup(){
    unique_ptr&lt;int&gt; a(new int);
    *a = 5;
}
</code></pre>

<p>As you can see, once it's created it's syntax is the same as a raw pointer, we can use the <code>*</code> operator to dereference it an access or modiify it's value, if we are working with objects like:</p>
<pre><code class="cpp">void ofApp::setup(){
    unique_ptr&lt;Particle&gt; p(new Particle);
    p-&gt;pos.set(20,20);
}
</code></pre>

<p>We can also use the <code>-&gt;</code> to access it's member variables and functions.</p>
<p>When the function goes out of scope, being unique_ptr an object, it's destructor will get called, which internally will call <code>delete</code> on the allocated memory so we don't need to call delete on unique_ptr at all.</p>
<p>Now let's say we want to move a unique_ptr into a vector:</p>
<pre><code class="cpp">void ofApp::setup(){
    unique_ptr&lt;int&gt; a(new int);
    *a = 5;

    vector&lt;unique_ptr&lt;int&gt; &gt; v;
    v.push_back(a);  // error
}
</code></pre>

<p>That will generate a long error, depending on the compiler really hard to understand, but what's going on is that a is still owned by ofApp::setup so we can't put it in the vector, what we can do is move it into the vector by explicitly saying that we want to move the ownership of that unique_ptr into the vector:</p>
<pre><code class="cpp">void ofApp::setup(){
    unique_ptr&lt;int&gt; a(new int);
    *a = 5;

    vector&lt;unique_ptr&lt;int&gt; &gt; v;
    v.push_back(move(a));
}
</code></pre>

<p>There's a problem that unique_ptr doesn't solve, we can still do:</p>
<pre><code class="cpp">void ofApp::setup(){
    unique_ptr&lt;int&gt; a(new int);
    *a = 5;

    vector&lt;unique_ptr&lt;int&gt; &gt; v;
    v.push_back(move(a));

    cout &lt;&lt; *a &lt;&lt; endl;
}
</code></pre>

<p>The compiler won't fail there but if we try to execute the application it'll crash since a is not owned by ofApp::setup anymore, having to explicitly use <code>move</code> tries to solve that problem. After using move, we can't use that variable anymore except through the vector. More modern langauages like <a href="http://www.rust-lang.org/">Rust</a> completely solve this by making the compiler detect this kind of uses of moved variables and producing a compiler error. This will probably be solved at some point in c++ but by now you need to be careful to not use a moved variable.</p>
<h3 id="shared_ptr">shared_ptr</h3>
<p>As we've seen before, sometimes having unique ownership is not enough, sometimes we need to share an object among several owners, in c++11 this is solved through the shared_ptr. The usage is pretty similar to the unique_ptr, we create it like:</p>
<pre><code class="cpp">void ofApp::setup(){
    shared_ptr&lt;int&gt; a(new int);
    *a = 5;

    vector&lt;shared_ptr&lt;int&gt; &gt; v;
    v.push_back(a);
}
</code></pre>

<p>The difference is that now both the vector and ofApp::setup have a reference to that object and doing:</p>
<pre><code class="cpp">void ofApp::setup(){
    shared_ptr&lt;int&gt; a(new int);
    *a = 5;

    vector&lt;shared_ptr&lt;int&gt; &gt; v;
    v.push_back(a);

    cout &lt;&lt; *a &lt;&lt; endl;
}
</code></pre>

<p>Is perfectly ok. The way a shared_ptr works is by keeping a count of how many references there are to it, whenever we make a copy of it, it increases that counter by one, whenever a reference is destroyed it decreases that reference by one. When the reference cound arrives to 0 it destroys the allocated memory. That reference counting is done atomically which means that we can share a shared_ptr across threads without having problems with the count. That doesn't mean that we can access the contained data safely in a multithreaded application, just that the reference count won't get wrong if we pass a shared_ptr accross different threads.</p>
<p><em>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.</em></p>
<p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a></p>

    		</div>
            
        </div><!-- End Page Wide -->      
      </div><!-- End Body Wrap -->
      
      <div id="footer">
        
  <p id="credits">

Last updated 
  
Wednesday, 19 February 2014 14:58:02 UTC
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/openframeworks/ofSite/commit/

333eec297b2c617222f4b2dfdcca53052b3c1cb5
">

333eec297b2c617222f4b2dfdcca53052b3c1cb5
</a>

<!--br/>RSS feeds for <a href="/feed">Entries</a-->

<br/>

</p>




<!--tracking -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-9614675-1");
pageTracker._trackPageview();
} catch(err) {}</script>






      </div> <!-- End Footer -->
    </div> <!-- End Content -->
  </body>
</html>







